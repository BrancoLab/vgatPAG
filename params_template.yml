motion_correction: # adapted from here: https://github.com/flatironinstitute/CaImAn/blob/master/demos/general/demo_pipeline_cnmfE.py
    gSig_filt: [2, 2] # used for high pass filtering in 1p data
    strides: [30, 30] # Can make it shakey
    overlaps: [11, 11] #
    max_shifts: [25, 25] # max shifts in rigid. makes a difference. usually 5-8. can be larger if motion is very rigid
    max_deviation_rigid: 7 # non-rigid shift deviation from rigid max shifts. makes a difference
    shifts_opencv: True
    num_frames_split: 100
    nonneg_movie: True


cnmf_fit:
    method_init: "corr_pnr"
    method_deconvolution: 'oasis'       # could use 'cvxpy' alternatively
    update_background_components: True  # sometimes setting to False improve the results
    normalize_init: False               # just leave as is
    center_psf: True                    # leave as is for 1 photon
    del_duplicates: True               # whether to remove duplicates from initialization     

    p: 1                        # order of the autoregressive system
    K: 15                       # upper bound on number of components per patch, in general None
    gSig: [2.5, 2.5]            #2.5  # gaussian width of a 2D gaussian kernel, which approximates a neuron. 
    gSiz: [8, 8]                # average diameter of a neuron, in general 4*gSig+1. 
    merging_thresh: .6          # default 0.7. merging threshold, max correlation allowed
    rf: 30                      # default 40. half-size of the patches in pixels. e.g., if rf=40, patches are 80x80
    stride: 15                  # amount of overlap between the patches in pixels
                                #   (keep it at least large as gSiz, i.e 4 times the neuron size gSig)
    tsub: 2                         # downsampling factor in time for initialization,
                                    #   increase if you have memory problems
    ssub: 1                     # downsampling factor in space for initialization,
                                    #   increase if you have memory problems
                                    #   you can pass them here as boolean vectors
    low_rank_background: None   # None leaves background of each patch intact,
                                    #   True performs global low-rank approximation if gnb>0
    nb: 0                       # number of background components (rank) if positive,
                                    #    else exact ring model with following settings
                                    #        gnb= 0: Return background as b and W
                                    #        gnb=-1: Return full rank background B
                                    #        gnb<-1: Don't return background
    nb_patch: 0                 # number of background components (rank) per patch if gnb>0,
                                    #     else it is set automatically
    min_corr: .8                # min peak value from correlation image
    min_pnr: 6                  # min peak to noise ration from PNR image
    ssub_B: 2                   # additional downsampling factor in space for background
    ring_size_factor: 1.4       # radius of ring is gSiz*ring_size_factor
    border_pix: 0               # number of pixels to not consider in the borders)